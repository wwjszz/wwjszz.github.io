[{"title":"无锁队列实现","url":"/2026/02/15/ConcurrentQueue/","content":"ConcurrentQueueFreeList由于存在ABA问题，导致如果按照简单的CAS操作，会导致操作在不应该成功的情况下成功。可以通过添加Tag避免ABA问题：\nDCAS每次比较时，不仅比较头指针，还需要比较tag。这样在任何在ABA之后执行的操作都会失败。这种方法的问题就是目标架构必须支持足够长度的无锁操作。当然也可以通过压缩指针等方式来使其达到要求。\n/** * Head的tag是整个链表中最大的。 * 以H1为例，当H1被get的时候，H1之后的结点的tag被增加为最大的。 * 如果H1被重新add，那么当前的head的结点的tag一定不会被之前的小，这就保证了两次的tag不一样。 * 当然在某种极端环境，会存在溢出，不过这种情况几乎不可能发生。 */void Add( Node* InNode ) noexcept &#123;    HeadPtr CurrentHead = Head().load( std::memory_order_relaxed );    HeadPtr NewHead&#123; InNode, 0 &#125;;    do &#123;        NewHead.Tag = CurrentHead.Tag + 1;        InNode-&gt;FreeListNext.store( CurrentHead.Ptr, std::memory_order_relaxed );    &#125; while ( !Head().compare_exchange_strong( CurrentHead, NewHead, std::memory_order_relaxed, std::memory_order_relaxed ) );&#125;Node* TryGet() noexcept &#123;    HeadPtr CurrentHead = Head().load( std::memory_order_relaxed );    HeadPtr NewHead;    while ( CurrentHead.Ptr != nullptr ) &#123;        NewHead.Ptr = CurrentHead.Ptr-&gt;FreeListNext.load( std::memory_order_relaxed );        NewHead.Tag = CurrentHead.Tag + 1;        if ( Head().compare_exchange_strong( CurrentHead, NewHead, std::memory_order_relaxed, std::memory_order_relaxed ) ) &#123;            break;        &#125;    &#125;    return CurrentHead.Ptr;&#125;\n\n引用计数引入一个计数，用来表示当前有多少对象在使用当前结点，这样add的时候，如果检测到有对象在使用当前结点，就可以将add的任务交给最后一个离开结点的结点。\n/** * 在链表中且没有对象在使用的结点的引用计数为1 */void Add( Node* InNode ) noexcept &#123;    // Set AddFlag first    if ( InNode-&gt;FreeListRefs.fetch_add( AddFlag, std::memory_order_relaxed ) == 0 ) &#123;        Node* CurrentHead = Head().load( std::memory_order_relaxed );        while ( true ) &#123;            // first update next then refs            InNode-&gt;FreeListNext.store( CurrentHead, std::memory_order_relaxed );            InNode-&gt;FreeListRefs.store( 1, std::memory_order_release );            // refs may increase            if ( !Head().compare_exchange_strong( CurrentHead, InNode, std::memory_order_relaxed, std::memory_order_relaxed ) ) &#123;                // if exchange failed, check if someone is using it                if ( InNode-&gt;FreeListRefs.fetch_add( AddFlag - 1, std::memory_order_release ) == 1 ) &#123;                    continue;                &#125; // else we can let the last user add it            &#125;            return;        &#125;    &#125;&#125;Node* TryGet() noexcept &#123;    Node* CurrentHead = Head().load( std::memory_order_relaxed );    while ( CurrentHead != nullptr ) &#123;        Node*    PrevHead = CurrentHead;        uint32_t Refs     = CurrentHead-&gt;FreeListRefs.load( std::memory_order_relaxed );        if ( ( Refs &amp; RefsMask ) == 0  // check if already taken or adding             || ( !CurrentHead-&gt;FreeListRefs.compare_exchange_strong( Refs, Refs + 1, std::memory_order_acquire,                                                                      std::memory_order_relaxed ) ) )  // try add refs        &#123;            CurrentHead = Head().load( std::memory_order_relaxed );            continue;        &#125;        // try Taken        Node* Next = CurrentHead-&gt;FreeListNext.load( std::memory_order_relaxed );        if ( Head().compare_exchange_strong( CurrentHead, Next, std::memory_order_relaxed, std::memory_order_relaxed ) ) &#123;            // taken success, decrease refcount twice, for our and list&#x27;s ref            CurrentHead-&gt;FreeListRefs.fetch_add( -2, std::memory_order_relaxed );            return CurrentHead;        &#125;        // taken failed, decrease refcount        Refs = PrevHead-&gt;FreeListRefs.fetch_add( -1, std::memory_order_relaxed );        if ( Refs == AddFlag + 1 ) &#123;            // no one is using it, add it back            InnerAdd( PrevHead );        &#125;    &#125;    return nullptr;&#125;\n\nLockFreeHashTableLockFree LinearSearch简单的线性表查找，基于CAS操作。\n/** * 简单的无锁线性表查找，INVALID_KEY=0 */void SetItem( int InKey, int InValue ) noexcept &#123;    for ( LinearSearchMapEntry&amp; Entry : Data ) &#123;        int CurrentKey = Entry.Key.Load();        if ( CurrentKey != InKey ) &#123;            if ( CurrentKey != 0 )                continue;            if ( !Entry.Key.CompareExchangeStrong( CurrentKey, InKey ) &amp;&amp; CurrentKey != 0 &amp;&amp; CurrentKey != InKey )                continue;        &#125;        Entry.Value.Store( InValue );        return;    &#125;&#125;int GetItem( int InKey ) const noexcept &#123;    for ( const LinearSearchMapEntry&amp; Entry : Data ) &#123;        int CurrentKey = Entry.Key.Load();        if ( CurrentKey == InKey )            return Entry.Value.Load();        if ( CurrentKey == 0 )            break;    &#125;    return 0;&#125;\n\n固定大小的HashTable查找过程与线性查找类似，只不过开始位置为hash(key)。\n/** * 固定大小的Hashtable */void SetItem( uint32_t InKey, uint32_t InValue ) noexcept &#123;    for ( uint32_t idx = IntegerHash( InKey );; ++idx ) &#123;        idx &amp;= ( N - 1 );        HashTableEntry&amp; Entry = Data[ idx ];        uint32_t CurrentKey = Entry.Key.Load();        if ( CurrentKey != InKey ) &#123;            if ( CurrentKey != 0 )                continue;            if ( !Entry.Key.CompareExchangeStrong( CurrentKey, InKey ) &amp;&amp; CurrentKey != 0 &amp;&amp; CurrentKey != InKey )                continue;        &#125;        Entry.Value.Store( InValue );        return;    &#125;&#125;int GetItem( uint32_t InKey ) const noexcept &#123;    for ( uint32_t idx = IntegerHash( InKey );; ++idx ) &#123;        idx &amp;= ( N - 1 );        const HashTableEntry&amp; Entry = Data[ idx ];        uint32_t CurrentKey = Entry.Key.Load();        if ( CurrentKey == InKey )            return Entry.Value.Load();        if ( CurrentKey == 0 )            break;    &#125;    return 0;&#125;\n\n可变大小的HashTable将多个固定大小的HashTable，链接起来就是可变大小的HashTable。\n/** * 如果发现不是从头部HashNode获取到的Value，则再把&#123;Key, Value&#125;写入头部HashNode */struct HashNode &#123;    constexpr HashNode() = default;    constexpr explicit HashNode( std::size_t InCapacity ) noexcept : Capacity( InCapacity ) &#123;&#125;    HashNode*   Prev&#123; nullptr &#125;;    std::size_t Capacity&#123; 0 &#125;;    Entry*      Entries&#123; nullptr &#125;;&#125;;HAKLE_CPP14_CONSTEXPR Entry* InnerGetEntry( const TKey&amp; Key, HashNode* CurrentMainHash ) const &#123;    std::size_t HashId = Hash( Key );    for ( HashNode* CurrentHash = CurrentMainHash; CurrentHash != nullptr; CurrentHash = CurrentHash-&gt;Prev ) &#123;        std::size_t Index = HashId;        while ( true ) &#123;            Index &amp;= CurrentHash-&gt;Capacity - 1;            TKey CurrentKey = CurrentHash-&gt;Entries[ Index ].First.load( std::memory_order_relaxed );            if ( CurrentKey == Key ) &#123;                TValue CurrentValue = CurrentHash-&gt;Entries[ Index ].Second.load( std::memory_order_acquire );                if ( CurrentHash != CurrentMainHash ) &#123;                    Index                          = HashId;                    const std::size_t MainCapacity = CurrentMainHash-&gt;Capacity;                    while ( true ) &#123;                        Index &amp;= MainCapacity - 1;                        auto Empty = INVALID_KEY;                        if ( CurrentMainHash-&gt;Entries[ Index ].First.compare_exchange_strong( Empty, Key, std::memory_order_acquire, std::memory_order_relaxed ) ) &#123;                            CurrentMainHash-&gt;Entries[ Index ].Second.store( CurrentValue, std::memory_order_release );                            break;                        &#125;                        ++Index;                    &#125;                &#125;                return &amp;CurrentMainHash-&gt;Entries[ Index ];            &#125;            if ( CurrentKey == INVALID_KEY ) &#123;                break;            &#125;            ++Index;        &#125;    &#125;    return nullptr;&#125;HAKLE_CPP14_CONSTEXPR bool InnerAdd( const TKey&amp; Key, const TValue&amp; InValue, HashNode* CurrentMainHash ) &#123;    std::size_t NewCount = EntriesCount.fetch_add( 1, std::memory_order_relaxed );    while ( true ) &#123;        if ( NewCount &gt;= ( CurrentMainHash-&gt;Capacity &gt;&gt; 1 ) &amp;&amp; !HashResizeInProgressFlag().test_and_set( std::memory_order_acquire ) ) &#123;            CurrentMainHash = MainHash().load( std::memory_order_acquire );            if ( NewCount &lt; ( CurrentMainHash-&gt;Capacity &gt;&gt; 1 ) ) &#123;                HashResizeInProgressFlag().clear( std::memory_order_relaxed );            &#125;            else &#123;                std::size_t NewCapacity = CurrentMainHash-&gt;Capacity &lt;&lt; 1;                while ( NewCount &gt;= NewCapacity &gt;&gt; 1 ) &#123;                    NewCount &lt;&lt;= 1;                &#125;                HashNode* NewHash = CreateNewHashNode( NewCapacity );                if ( NewHash == nullptr ) &#123;                    EntriesCount.fetch_sub( 1, std::memory_order_relaxed );                    return false;                &#125;                NewHash-&gt;Prev = CurrentMainHash;                MainHash().store( NewHash, std::memory_order_release );                HashResizeInProgressFlag().clear( std::memory_order_release );                CurrentMainHash = NewHash;            &#125;        &#125;        // if there is enough space, add the new entry        if ( NewCount &lt; ( CurrentMainHash-&gt;Capacity &gt;&gt; 1 ) + ( CurrentMainHash-&gt;Capacity &gt;&gt; 2 ) ) &#123;            std::size_t HashId = Hash( Key );            std::size_t Index  = HashId;            while ( true ) &#123;                Index &amp;= CurrentMainHash-&gt;Capacity - 1;                TKey CurrentKey = CurrentMainHash-&gt;Entries[ Index ].First.load( std::memory_order_relaxed );                if ( CurrentKey == INVALID_KEY ) &#123;                    TKey Empty = INVALID_KEY;                    if ( CurrentMainHash-&gt;Entries[ Index ].First.compare_exchange_strong( Empty, Key, std::memory_order_acq_rel, std::memory_order_relaxed ) ) &#123;                        CurrentMainHash-&gt;Entries[ Index ].Second.store( InValue, std::memory_order_release );                        break;                    &#125;                &#125;                ++Index;            &#125;            return true;        &#125;        CurrentMainHash = MainHash().load( std::memory_order_acquire );    &#125;&#125;\n\nLockFree SPMC Queue这个项目的SPMC队列本质是一个Block数组的链表，Block内有BlockSize个元素，与可变大小的HashTable类似，SPMC队列也是使用链表来实现可变大小。只不过对于FastQueue来说，内部更能看作是一个Block的链表，IndexEntry只是用来承载Block，以便于计算索引等等。SlowQueue的话则没有利用这个链表，它纯粹是一个IndexEntry数组。\nFastQueueFastQueue会将使用过的Block放在链表里但不会回收，当用到时直接放在空的IndexEntry就可以使用\nSlowQueueSlowQueue设计上是全局的Queue，所以尽可能的减少内存占用，SlowQueue会将使用过的Block直接返回给BlockManager，以便供其他队列使用。\n"}]